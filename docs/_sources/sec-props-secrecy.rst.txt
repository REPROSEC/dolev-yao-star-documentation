.. _sec-secrecy:

Secrecy
-------

Secrecy is a common and important property,
saying that some value stays secret during runs of a protocol,
as long as all participants are honest.

For example, for the Online? protocol,
we want to show secrecy of the nonce :math:`n_A` that is generated by Alice.
In the beginning of this chapter,
we had the intuitive trace-based description of secrecy:

  For every trace complying with the Online? protocol,
  the attacker does not get to know the nonce :math:`n_A`
  that Alice generated for Bob,
  as long as both Alice and Bob are honest.

If we spell out the quantifiers and logical connectives explicitly in the above description,
we can state the property as:

  :math:`\forall` trace :math:`tr`
  :math:`\forall` Alice, Bob, nonce :math:`n_A`:
        (:math:`tr` complies with the Online? protocol :math:`\land` Alice generated :math:`n_A` for Bob on :math:`tr`)
        :math:`\implies`
              
          (Alice and Bob are honest on :math:`tr`
          :math:`\implies` attacker does not know :math:`n_A` from :math:`tr`).

We have seen previously in the attacker model,
that we describe things the attacker knows and how he corrupts participants.
This is the contrary to "honest" (:math:`\lnot` is corrupt) and "attacker does not know" (:math:`\lnot` (attacker knows)).
We hence rephrase the last line to the equivalent:
                
  attacker knows :math:`n_A` from :math:`tr` :math:`\implies` one of Alice or Bob is corrupt on :math:`tr`

Now recall that we can express a formula of the form

  :math:`\forall` variables:
  pre_condition variables :math:`\implies` post_condition variables

as an F* :fstar:`Lemma`:
  
.. code::

   val my_lemma:
     variables ->
     Lemma
       (requires pre_condition variables)
       (ensures  post_condition variables)

Our secrecy formula from above already has the right structure
to be expressed as an F* lemma.
However, we are missing the part about "Alice generated the nonce for Bob".
From our model of the Online? protocol,
we know that when Alice generates the nonce and sends it to Bob,
she stores the nonce together with Bob in a :fstar:`SentPing` state.
We can thus write
:fstar:`state_was_set_some_id tr alice (SentPing {bob; n_a})`
to say that Alice generated the nonce :math:`n_A` for Bob.
The property :fstar:`state_was_set_some_id` just says, that at some point on the trace,
Alice stored the state in one of her sessions.

Putting everything together, we can state the first formal secrecy property in DY*:

.. example:: Nonce Secrecy for the Online? protocol

   The secrecy of the nonce :math:`n_A` that Alice generates for Bob,
   is expresses as the following F* Lemma:
   
   .. code::

     val n_a_secrecy:
       tr:trace -> alice:principal -> bob:principal -> n_a:bytes ->
       Lemma
       (requires
          complies_with_online_protocol tr /\
          state_was_set_some_id tr alice (SentPing {bob; n_a})
       )
       (ensures
          attacker_knows tr n_a ==>
          (principal_is_corrupt tr alice \/ principal_is_corrupt tr bob)
       )

   .. reveal::
        :header: Alternative

        It is of course equivalent to move the :fstar:`attacker_knows` term from the :fstar:`ensures` clause
        to the :fstar:`requires` clause like this:

        .. code::

           val n_a_secrecy:
             tr:trace -> alice:principal -> bob:principal -> n_a:bytes ->
             Lemma
             (requires
                complies_with_online_protocol tr /\
                state_was_set_some_id tr alice (SentPing {bob; n_a}) /\
                attacker_knows tr n_a
             )
             (ensures
                principal_is_corrupt tr alice \/ principal_is_corrupt tr bob
             )

.. attention::

   If you try to copy the security property from above
   to your DY* model of the Online? protocol,
   you will get an error (``Identifier not found``),
   since we didn't define ``complies_with_online_protocol`` yet.
   We'll do that only in the next chapter.
   
We can strengthen this secrecy property for the Online? protocol,
by saying that nonces stored in *any* of Alice's states are secret.
So far, we only considered those in :fstar:`SentPing` states,
but we have the same secrecy guarantee for nonces stored in her :fstar:`ReceivedAck` states.
So the full secrecy property, we want to show for the Online? protocol is

.. example:: Nonce Secrecy for Online? Protocol

   .. code::

        val n_a_secrecy:
          tr:trace -> alice:principal -> bob:principal -> n_a:bytes ->
          Lemma
          (requires
             complies_with_online_protocol tr /\ (
               state_was_set_some_id tr alice (SentPing {bob; n_a}) \/
               state_was_set_some_id tr alice (ReceivedAck {bob; n_a} )
             )
          )
          (ensures
             attacker_knows tr n_a ==>
             (principal_is_corrupt tr alice \/ principal_is_corrupt tr bob)
          )


.. exercise:: Secrecy of the Nonce :math:`n_A` for the NSL protocol

   Write down the secrecy property for the nonce :math:`n_A` in the NSL protocol
   as an F* lemma.
   
   1. What is the intuitive textual description of the secrecy property?

      .. toggle-answer::

         For every trace complying with the NSL protocol,
         the attacker does not get to know the nonce :math:`n_A`
         that Alice generated for Bob,
         as long as both Alice and Bob are honest.

         Or in the stronger version:

         For every trace complying with the NSL protocol,
         the attacker does not get to know the nonce :math:`n_A`
         that Alice stores in one of her states associated with Bob,
         as long as both Alice and Bob are honest.

   2. Write the intuitive description as formula using quantifiers and logical connectives.

      .. toggle-answer::
         
         :math:`\forall` trace :math:`tr`
         :math:`\forall` Alice, Bob, nonce :math:`n_A`:
               (:math:`tr` complies with the NSL protocol :math:`\land`
               Alice stores :math:`n_A` in one of her states associated with Bob on :math:`tr`)
               :math:`\implies`

                     (attacker knows :math:`n_A` from :math:`tr` :math:`\implies` one of Alice or Bob is corrupt on :math:`tr`)

   3. Write the formula as an F* lemma.
      You can use ``complies_with_nsl`` as blackbox.

      .. toggle-answer::

         .. code::

            val n_a_secrecy:
              tr:trace -> alice:principal -> bob:principal -> n_a:bytes ->
              Lemma
              (requires
                complies_with_nsl tr /\ 
                ( (state_was_set_some_id tr alice (InitiatorSendingMsg1 bob n_a)) \/
                  (exists n_b. state_was_set_some_id tr alice (InitiatorSendingMsg3 bob n_a n_b)))
                ) /\
                attacker_knows tr n_a
              )
              (ensures principal_is_corrupt tr alice \/ principal_is_corrupt tr bob)

.. exercise:: Secrecy of the Nonce :math:`n_B` for the NSL protocol

   Write down the secrecy property for the nonce :math:`n_B` in the NSL protocol
   as an F* lemma.


   .. toggle-answer::

      .. code::

         val n_b_secrecy:
           tr:trace -> alice:principal -> bob:principal -> n_b:bytes ->
           Lemma
           (requires
             complies_with_nsl tr /\
             ( (exists n_a. state_was_set_some_id tr bob (ResponderSendingMsg2 alice n_a n_b)) \/
               (exists n_a. state_was_set_some_id tr bob (ResponderReceivedMsg3 alice n_a n_b))
             ) /\
             attacker_knows tr n_b
           )
           (ensures principal_is_corrupt tr alice \/ principal_is_corrupt tr bob)


To summarize:

.. remember:: General Structure of Secrecy Property

   Secrecy properties usually look like the following

   .. code::

      val secrecy:
          tr:trace -> alice:principal -> bob:principal -> secret_value:bytes ->
          Lemma
          (requires
            complies_with_protocol tr /\
            ( (state_was_set_some_id tr alice (SomeState1 bob secret_value ...)) \/
              (state_was_set_some_id tr alice (SomeState2 bob secret_value ...)) \/
              ...
            ) /\
            attacker_knows tr secrect_value
          )
          (ensures principal_is_corrupt tr alice \/ principal_is_corrupt tr bob)
  
   Sometimes the above can be strengthened
   to consider also states *of Bob*.
   In that case, we add some more ``state_was_set_some_id`` clauses to the :fstar:`requires`:

   .. code::

      (state_was_set_some_id tr bob (SomeState alice secret_value ...))
